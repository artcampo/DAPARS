Grammar:
PROG -> E  init 
E -> T E' 
E' -> + T E' 
E' -> - T E' 
E' -> {empty} 
T -> F T' 
T' -> * F T' 
T' -> / F T' 
T' -> {empty} 
F -> ( E ) 
F -> {num} 
F -> {nam} 

---------------------------------------------------
Parsing: "void main(){int a;a=1;a=2;a=3; }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Literal: 1 [int Rvalue]
--Assign
---a [int Lvalue Write Value]
---Literal: 2 [int Rvalue]
--Assign
---a [int Lvalue Write Value]
---Literal: 3 [int Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }

---------------------------------------------------
Parsing: "void main(){int a;a=2+3+4; }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Op: +  [int Rvalue]
----Op: +  [int Rvalue]
-----Literal: 2 [int Rvalue]
-----Literal: 3 [int Rvalue]
----Literal: 4 [int Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }


---------------------------------------------------
Parsing: "void main(){int a;a=2++3+4; }"
Expecting numerical or lpar at: "nt a;a=2++" -> "3+4; }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a
---Op: + 
----Op: + 
-----Literal: 2
-----Literal: 3
----Literal: 4


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }


---------------------------------------------------
Parsing: "void main(){int a;a=1+2;a=3+4; }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Op: +  [int Rvalue]
----Literal: 1 [int Rvalue]
----Literal: 2 [int Rvalue]
--Assign
---a [int Lvalue Write Value]
---Op: +  [int Rvalue]
----Literal: 3 [int Rvalue]
----Literal: 4 [int Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }


---------------------------------------------------
Parsing: "void main(){int a;a=1+2;a=3+4;a=5+6; }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Op: +  [int Rvalue]
----Literal: 1 [int Rvalue]
----Literal: 2 [int Rvalue]
--Assign
---a [int Lvalue Write Value]
---Op: +  [int Rvalue]
----Literal: 3 [int Rvalue]
----Literal: 4 [int Rvalue]
--Assign
---a [int Lvalue Write Value]
---Op: +  [int Rvalue]
----Literal: 5 [int Rvalue]
----Literal: 6 [int Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }


Grammar:
PROG -> E  init 
E -> T E' 
E' -> + T E' 
E' -> - T E' 
E' -> {empty} 
T -> F T' 
T' -> * F T' 
T' -> / F T' 
T' -> {empty} 
F -> ( E ) 
F -> {num} 
F -> {nam} 

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3;} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3;} }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Literal: 1 [int Rvalue]
--IfStmt:
---Cond: Literal: 2 [int Rvalue]
---Then:
----Assign
-----a [int Lvalue Write Value]
-----Literal: 3 [int Rvalue]



Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3;} a=4; }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3;} a=4; }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Literal: 1 [int Rvalue]
--IfStmt:
---Cond: Literal: 2 [int Rvalue]
---Then:
----Assign
-----a [int Lvalue Write Value]
-----Literal: 3 [int Rvalue]

--Assign
---a [int Lvalue Write Value]
---Literal: 4 [int Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3+4+5;} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3+4+5;} }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Literal: 1 [int Rvalue]
--IfStmt:
---Cond: Literal: 2 [int Rvalue]
---Then:
----Assign
-----a [int Lvalue Write Value]
-----Op: +  [int Rvalue]
------Op: +  [int Rvalue]
-------Literal: 3 [int Rvalue]
-------Literal: 4 [int Rvalue]
------Literal: 5 [int Rvalue]



Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3+4+5;} a=6; }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3+4+5;} a=6; }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Literal: 1 [int Rvalue]
--IfStmt:
---Cond: Literal: 2 [int Rvalue]
---Then:
----Assign
-----a [int Lvalue Write Value]
-----Op: +  [int Rvalue]
------Op: +  [int Rvalue]
-------Literal: 3 [int Rvalue]
-------Literal: 4 [int Rvalue]
------Literal: 5 [int Rvalue]

--Assign
---a [int Lvalue Write Value]
---Literal: 6 [int Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){if(3){a=4;if(5){a=6;}}} }"
[err:21] if's condition is not a bool at: "){a=4;if(5" -> "){a=6;}}} }"
[err:21] if's condition is not a bool at: "if(2){if(3" -> "){a=4;if(5){a=6;}}} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){if(3){a=4;if(5){a=6;}}} }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Literal: 1 [int Rvalue]
--IfStmt:
---Cond: Literal: 2 [int Rvalue]
---Then:
----IfStmt:
-----Cond: Literal: 3 [int Rvalue]
-----Then:
------Assign
-------a [int Lvalue Write Value]
-------Literal: 4 [int Rvalue]
------IfStmt:
-------Cond: Literal: 5 [int Rvalue]
-------Then:
--------Assign
---------a [int Lvalue Write Value]
---------Literal: 6 [int Rvalue]





Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}
Scope 3: {}
Scope 4: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){if(3){a=4+5;if(6){a=7+8;}}} }"
[err:21] if's condition is not a bool at: "a=4+5;if(6" -> "){a=7+8;}}} }"
[err:21] if's condition is not a bool at: "if(2){if(3" -> "){a=4+5;if(6){a=7+8;}}} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){if(3){a=4+5;if(6){a=7+8;}}} }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Literal: 1 [int Rvalue]
--IfStmt:
---Cond: Literal: 2 [int Rvalue]
---Then:
----IfStmt:
-----Cond: Literal: 3 [int Rvalue]
-----Then:
------Assign
-------a [int Lvalue Write Value]
-------Op: +  [int Rvalue]
--------Literal: 4 [int Rvalue]
--------Literal: 5 [int Rvalue]
------IfStmt:
-------Cond: Literal: 6 [int Rvalue]
-------Then:
--------Assign
---------a [int Lvalue Write Value]
---------Op: +  [int Rvalue]
----------Literal: 7 [int Rvalue]
----------Literal: 8 [int Rvalue]





Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}
Scope 3: {}
Scope 4: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3;}if(4){a=5;}else{a=6;} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3;}if(4){a=5;}else{a=6;} }"
[err:21] if's condition is not a bool at: "{a=3;}if(4" -> "){a=5;}else{a=6;} }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Literal: 1 [int Rvalue]
--IfStmt:
---Cond: Literal: 2 [int Rvalue]
---Then:
----Assign
-----a [int Lvalue Write Value]
-----Literal: 3 [int Rvalue]

--IfStmt:
---Cond: Literal: 4 [int Rvalue]
---Then:
----Assign
-----a [int Lvalue Write Value]
-----Literal: 5 [int Rvalue]
---Else:
----Assign
-----a [int Lvalue Write Value]
-----Literal: 6 [int Rvalue]



Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}
Scope 3: {}
Scope 4: {}

---------------------------------------------------
Parsing: "void main(){int a; int b; bool c; }"

AST dump:
-FuncDef: main
--int a 
--int b 
--bool c 


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 1 b of type int]
2: Symbol: [ in scope 1 c of type bool]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(0:a) (1:b) (2:c) }

---------------------------------------------------
Parsing: "void main(){int b, c, d; bool e f; }"
[err:19] Variable declarations must be separated with comma. at: "; bool e f" -> "; }"

AST dump:
-FuncDef: main
--int b int c int d 
--bool e bool f 


Declaration Table:
0: Symbol: [ in scope 1 b of type int]
1: Symbol: [ in scope 1 c of type int]
2: Symbol: [ in scope 1 d of type int]
3: Symbol: [ in scope 1 e of type bool]
4: Symbol: [ in scope 1 f of type bool]
5: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(5:main) }
Scope 1: {(0:b) (1:c) (2:d) (3:e) (4:f) }

---------------------------------------------------
Parsing: "void main(){int a; a=1; }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Literal: 1 [int Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }

---------------------------------------------------
Parsing: "void main(){int a; a=(1+2+3); }"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Op: +  [int Rvalue]
----Op: +  [int Rvalue]
-----Literal: 1 [int Rvalue]
-----Literal: 2 [int Rvalue]
----Literal: 3 [int Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }

---------------------------------------------------
Parsing: "void main(){int a b c; b=1; c=2; a=(1+b+c); }"
[err:19] Variable declarations must be separated with comma. at: "(){int a b" -> " c; b=1; c=2; a=(1+b+c); }"
[err:19] Variable declarations must be separated with comma. at: "{int a b c" -> "; b=1; c=2; a=(1+b+c); }"

AST dump:
-FuncDef: main
--int a int b int c 
--Assign
---b
---Literal: 1
--Assign
---c
---Literal: 2
--Assign
---a
---Op: + 
----Op: + 
-----Literal: 1
-----b
----c


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 1 b of type int]
2: Symbol: [ in scope 1 c of type int]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(0:a) (1:b) (2:c) }

---------------------------------------------------
Parsing: "void main(){ int a; int b; int a; }"
[err:15] Symbol already declared. at: " b; int a;" -> " }"
[err:31] function body empty at: "; int a; }" -> ""
AST not build (no functions) at: "; int a; }" -> ""
AST not build (fatal errors) at: "; int a; }" -> ""

---------------------------------------------------
Parsing: "void main(){ int a; if(1){int b;} }"
[err:21] if's condition is not a bool at: "nt a; if(1" -> "){int b;} }"

AST dump:
-FuncDef: main
--int a 
--IfStmt:
---Cond: Literal: 1 [int Rvalue]
---Then:
----int b 



Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 2 b of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(0:a) }
Scope 2: {(1:b) }

---------------------------------------------------
Parsing: "void main(){ int a; if(1){int b;}else{int c;} }"
[err:21] if's condition is not a bool at: "nt a; if(1" -> "){int b;}else{int c;} }"

AST dump:
-FuncDef: main
--int a 
--IfStmt:
---Cond: Literal: 1 [int Rvalue]
---Then:
----int b 
---Else:
----int c 



Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 2 b of type int]
2: Symbol: [ in scope 3 c of type int]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(0:a) }
Scope 2: {(1:b) }
Scope 3: {(2:c) }

---------------------------------------------------
Parsing: "void main(){ int a; while(1 + 2){ int c; c = 1+2; } }"
[err:20] while's condition is not a bool at: " while(1 +" -> " 2){ int c; c = 1+2; } }"

AST dump:
-FuncDef: main
--int a 
--WhileStmt:
---Cond: Op: +  [int Rvalue]
----Literal: 1 [int Rvalue]
----Literal: 2 [int Rvalue]
---Body:
----int c 
----Assign
-----c [int Lvalue Write Value]
-----Op: +  [int Rvalue]
------Literal: 1 [int Rvalue]
------Literal: 2 [int Rvalue]



Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 2 c of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(0:a) }
Scope 2: {(1:c) }

---------------------------------------------------
Parsing: "void main(){ bool a, b; a = true; b = false; }"

AST dump:
-FuncDef: main
--bool a bool b 
--Assign
---a [bool Lvalue Write Value]
---Literal: 1 [bool Rvalue]
--Assign
---b [bool Lvalue Write Value]
---Literal: 0 [bool Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type bool]
1: Symbol: [ in scope 1 b of type bool]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(0:a) (1:b) }

---------------------------------------------------
Parsing: "void main(){ int* a; int* b; }"

AST dump:
-FuncDef: main
--int* a 
--int* b 


Declaration Table:
0: Symbol: [ in scope 1 a of type int*]
1: Symbol: [ in scope 1 b of type int*]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(0:a) (1:b) }

---------------------------------------------------
Parsing: "void main(){ int* a; int b, c; b = 2; a = &b; c = *a; }"

AST dump:
-FuncDef: main
--int* a 
--int b int c 
--Assign
---b [int Lvalue Write Value]
---Literal: 2 [int Rvalue]
--Assign
---a [int* Lvalue Write Value]
---@ [int* Lvalue]
----b [int Lvalue Read Address]
--Assign
---c [int Lvalue Write Value]
---* [int Lvalue Read]
----a [int* Lvalue Read Value]


Declaration Table:
0: Symbol: [ in scope 1 a of type int*]
1: Symbol: [ in scope 1 b of type int]
2: Symbol: [ in scope 1 c of type int]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(0:a) (1:b) (2:c) }

---------------------------------------------------
Parsing: "void main(){int a; a= 2;} void f(){bool a; a=3;}"
[err:18] Incompatible types in assignment: bool to int at: "{bool a; a" -> "=3;}"

AST dump:
-FuncDef: main
--int a 
--Assign
---a [int Lvalue Write Value]
---Literal: 2 [int Rvalue]
-FuncDef: f
--bool a 
--Assign
---a [bool Lvalue Write Value]
---Literal: 3 [int Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]
2: Symbol: [ in scope 2 a of type bool]
3: Symbol: [ in scope 0 f of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) (3:f) }
Scope 1: {(0:a) }
Scope 2: {(2:a) }

---------------------------------------------------
Parsing: "class O1{} void main(){ O1 a;}"

AST dump:
-FuncDef: main
--O1 a 
-ClassDef: O1


Declaration Table:
0: Symbol: [ in scope 2 a of type O1]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 2: {(0:a) }
HScope of O1 1: {}

---------------------------------------------------
Parsing: "class O1{int a;} void main(){ O1 inst; int b; b = inst.a;}"

AST dump:
-FuncDef: main
--O1 inst 
--int b 
--Assign
---b [int Lvalue Write Value]
---inst.a [int]
----inst [O1]
----a
-ClassDef: O1


Declaration Table:
1: Symbol: [ in scope 2 inst of type O1]
2: Symbol: [ in scope 2 b of type int]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:main) }
Scope 2: {(1:inst) (2:b) }
HScope of O1 1: {(0:a) }

---------------------------------------------------
Parsing: "class O1{int a;} class O2{ O1 o1;} void main(){ O2 inst; int b; b = inst.o1.a;}"

AST dump:
-FuncDef: main
--O2 inst 
--int b 
--Assign
---b [int Lvalue Write Value]
---inst.o1.a [int]
----inst.o1 [O1]
-----inst [O2]
-----o1
----a
-ClassDef: O1
-ClassDef: O2


Declaration Table:
2: Symbol: [ in scope 3 inst of type O2]
3: Symbol: [ in scope 3 b of type int]
4: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(4:main) }
Scope 3: {(2:inst) (3:b) }
HScope of O1 1: {(0:a) }
HScope of O2 2: {(1:o1) }

---------------------------------------------------
Parsing: "class O1{int f(int a, int b){int c; c = a+b; return c;}} void main(){ O1 inst; int b; b = inst.f(1,2);}"

AST dump:
-FuncDef: main
--O1 inst 
--int b 
--Assign
---b [int Lvalue Write Value]
---FuncRet: int [int Rvalue]
----FuncCall: inst.f [function: (int, int)->int]
-----inst.f [function: (int, int)->int]
------inst [O1]
------f
-----Literal: 1 [int]
-----Literal: 2 [int]
-ClassDef: O1


Declaration Table:
0: Symbol: [ in scope 2 a of type int]
1: Symbol: [ in scope 2 b of type int]
2: Symbol: [ in scope 2 c of type int]
4: Symbol: [ in scope 3 inst of type O1]
5: Symbol: [ in scope 3 b of type int]
6: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(6:main) }
Scope 3: {(4:inst) (5:b) }
HScope of O1 1: {(3:f) }


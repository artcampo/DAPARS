Grammar:
PROG -> E  init 
E -> T E' 
E' -> + T E' 
E' -> - T E' 
E' -> {empty} 
T -> F T' 
T' -> * F T' 
T' -> / F T' 
T' -> {empty} 
F -> ( E ) 
F -> {num} 
F -> {nam} 

---------------------------------------------------
Parsing: "void main(){int a; (a=1); }"
[err:14] Expecting rpar after expression. at: "int a; (a=" -> "1); }"
[err:4] Expecting semicolon after Expr. at: "t a; (a=1)" -> "; }"
[err:3] Block not finishing in rcbr at: "t a; (a=1)" -> "; }"
[err:31] function body empty at: "t a; (a=1)" -> "; }"
[err:30] function declaration's body not closed with '}' at: "t a; (a=1)" -> "; }"
AST not build (no functions) at: "t a; (a=1)" -> "; }"
AST not build (fatal errors) at: "t a; (a=1)" -> "; }"

---------------------------------------------------
Parsing: "void main(){int a;a=1;a=2;a=3; }"

AST pretty:
int a 
a=1
a=2
a=3

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Literal: 1 [int Rvalue]
-Assign
--a [int Lvalue Write Value]
--Literal: 2 [int Rvalue]
-Assign
--a [int Lvalue Write Value]
--Literal: 3 [int Rvalue]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }

---------------------------------------------------
Parsing: "void main(){int a;a=2+3+4; }"

AST pretty:
int a 
a=( ( 2 + 3 ) + 4 )

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Op: +  [int Rvalue]
---Op: +  [int Rvalue]
----Literal: 2 [int Rvalue]
----Literal: 3 [int Rvalue]
---Literal: 4 [int Rvalue]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }


---------------------------------------------------
Parsing: "void main(){int a;a=2++3+4; }"
Expecting numerical or lpar at: "nt a;a=2++" -> "3+4; }"

AST pretty:
int a 
a=( ( 2 + 3 ) + 4 )

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Op: +  [int Rvalue]
---Op: +  [int Rvalue]
----Literal: 2 [int Rvalue]
----Literal: 3 [int Rvalue]
---Literal: 4 [int Rvalue]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }


---------------------------------------------------
Parsing: "void main(){int a;a=1+2;a=3+4; }"

AST pretty:
int a 
a=( 1 + 2 )
a=( 3 + 4 )

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Op: +  [int Rvalue]
---Literal: 1 [int Rvalue]
---Literal: 2 [int Rvalue]
-Assign
--a [int Lvalue Write Value]
--Op: +  [int Rvalue]
---Literal: 3 [int Rvalue]
---Literal: 4 [int Rvalue]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }


---------------------------------------------------
Parsing: "void main(){int a;a=1+2;a=3+4;a=5+6; }"

AST pretty:
int a 
a=( 1 + 2 )
a=( 3 + 4 )
a=( 5 + 6 )

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Op: +  [int Rvalue]
---Literal: 1 [int Rvalue]
---Literal: 2 [int Rvalue]
-Assign
--a [int Lvalue Write Value]
--Op: +  [int Rvalue]
---Literal: 3 [int Rvalue]
---Literal: 4 [int Rvalue]
-Assign
--a [int Lvalue Write Value]
--Op: +  [int Rvalue]
---Literal: 5 [int Rvalue]
---Literal: 6 [int Rvalue]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }


Grammar:
PROG -> E  init 
E -> T E' 
E' -> + T E' 
E' -> - T E' 
E' -> {empty} 
T -> F T' 
T' -> * F T' 
T' -> / F T' 
T' -> {empty} 
F -> ( E ) 
F -> {num} 
F -> {nam} 

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3;} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3;} }"

AST pretty:
int a 
a=1
if(2){
  a=3
  }

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Literal: 1 [int Rvalue]
-IfStmt:
--Cond: Literal: 2 [int Rvalue]
--Then:
---Assign
----a [int Lvalue Write Value]
----Literal: 3 [int Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3;} a=4; }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3;} a=4; }"

AST pretty:
int a 
a=1
if(2){
  a=3
  }
a=4

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Literal: 1 [int Rvalue]
-IfStmt:
--Cond: Literal: 2 [int Rvalue]
--Then:
---Assign
----a [int Lvalue Write Value]
----Literal: 3 [int Rvalue]

-Assign
--a [int Lvalue Write Value]
--Literal: 4 [int Rvalue]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3+4+5;} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3+4+5;} }"

AST pretty:
int a 
a=1
if(2){
  a=( ( 3 + 4 ) + 5 )
  }

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Literal: 1 [int Rvalue]
-IfStmt:
--Cond: Literal: 2 [int Rvalue]
--Then:
---Assign
----a [int Lvalue Write Value]
----Op: +  [int Rvalue]
-----Op: +  [int Rvalue]
------Literal: 3 [int Rvalue]
------Literal: 4 [int Rvalue]
-----Literal: 5 [int Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3+4+5;} a=6; }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3+4+5;} a=6; }"

AST pretty:
int a 
a=1
if(2){
  a=( ( 3 + 4 ) + 5 )
  }
a=6

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Literal: 1 [int Rvalue]
-IfStmt:
--Cond: Literal: 2 [int Rvalue]
--Then:
---Assign
----a [int Lvalue Write Value]
----Op: +  [int Rvalue]
-----Op: +  [int Rvalue]
------Literal: 3 [int Rvalue]
------Literal: 4 [int Rvalue]
-----Literal: 5 [int Rvalue]

-Assign
--a [int Lvalue Write Value]
--Literal: 6 [int Rvalue]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){if(3){a=4;if(5){a=6;}}} }"
[err:21] if's condition is not a bool at: "){a=4;if(5" -> "){a=6;}}} }"
[err:21] if's condition is not a bool at: "if(2){if(3" -> "){a=4;if(5){a=6;}}} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){if(3){a=4;if(5){a=6;}}} }"

AST pretty:
int a 
a=1
if(2){
  if(3){
    a=4
    if(5){
      a=6
      }
    }
  }

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Literal: 1 [int Rvalue]
-IfStmt:
--Cond: Literal: 2 [int Rvalue]
--Then:
---IfStmt:
----Cond: Literal: 3 [int Rvalue]
----Then:
-----Assign
------a [int Lvalue Write Value]
------Literal: 4 [int Rvalue]
-----IfStmt:
------Cond: Literal: 5 [int Rvalue]
------Then:
-------Assign
--------a [int Lvalue Write Value]
--------Literal: 6 [int Rvalue]




Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}
Scope 3: {}
Scope 4: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){if(3){a=4+5;if(6){a=7+8;}}} }"
[err:21] if's condition is not a bool at: "a=4+5;if(6" -> "){a=7+8;}}} }"
[err:21] if's condition is not a bool at: "if(2){if(3" -> "){a=4+5;if(6){a=7+8;}}} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){if(3){a=4+5;if(6){a=7+8;}}} }"

AST pretty:
int a 
a=1
if(2){
  if(3){
    a=( 4 + 5 )
    if(6){
      a=( 7 + 8 )
      }
    }
  }

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Literal: 1 [int Rvalue]
-IfStmt:
--Cond: Literal: 2 [int Rvalue]
--Then:
---IfStmt:
----Cond: Literal: 3 [int Rvalue]
----Then:
-----Assign
------a [int Lvalue Write Value]
------Op: +  [int Rvalue]
-------Literal: 4 [int Rvalue]
-------Literal: 5 [int Rvalue]
-----IfStmt:
------Cond: Literal: 6 [int Rvalue]
------Then:
-------Assign
--------a [int Lvalue Write Value]
--------Op: +  [int Rvalue]
---------Literal: 7 [int Rvalue]
---------Literal: 8 [int Rvalue]




Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}
Scope 3: {}
Scope 4: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3;}else{4;} }"
[err:] assignment missing '=' at: "3;}else{4;" -> "} }"
[err:3] Block not finishing in rcbr at: "3;}else{4;" -> "} }"
Statements within else wrong. at: "3;}else{4;" -> "} }"
else missing rcbr. at: "3;}else{4;" -> "} }"
[err:3] Block not finishing in rcbr at: "3;}else{4;" -> "} }"
[err:31] function body empty at: "3;}else{4;" -> "} }"
[err:30] function declaration's body not closed with '}' at: "3;}else{4;" -> "} }"
AST not build (no functions) at: "3;}else{4;" -> "} }"
AST not build (fatal errors) at: "3;}else{4;" -> "} }"

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3;}if(4){a=5;}else{a=6;} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3;}if(4){a=5;}else{a=6;} }"
[err:21] if's condition is not a bool at: "{a=3;}if(4" -> "){a=5;}else{a=6;} }"

AST pretty:
int a 
a=1
if(2){
  a=3
  }
if(4){
  a=5
  }
else{
  a=6
  }

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Literal: 1 [int Rvalue]
-IfStmt:
--Cond: Literal: 2 [int Rvalue]
--Then:
---Assign
----a [int Lvalue Write Value]
----Literal: 3 [int Rvalue]

-IfStmt:
--Cond: Literal: 4 [int Rvalue]
--Then:
---Assign
----a [int Lvalue Write Value]
----Literal: 5 [int Rvalue]
--Else:
---Assign
----a [int Lvalue Write Value]
----Literal: 6 [int Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }
Scope 2: {}
Scope 3: {}
Scope 4: {}

---------------------------------------------------
Parsing: "void main(){int a; int b; bool c; }"

AST pretty:
int a 
int b 
bool c 

AST dump:
-int a 
-int b 
-bool c 

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 1 b of type int]
2: Symbol: [ in scope 1 c of type bool]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(0:a) (1:b) (2:c) }

---------------------------------------------------
Parsing: "void main(){int b, c, d; bool e f; }"
[err:19] Variable declarations must be separated with comma. at: "; bool e f" -> "; }"

AST pretty:
int b int c int d 
bool e bool f 

AST dump:
-int b int c int d 
-bool e bool f 

Declaration Table:
0: Symbol: [ in scope 1 b of type int]
1: Symbol: [ in scope 1 c of type int]
2: Symbol: [ in scope 1 d of type int]
3: Symbol: [ in scope 1 e of type bool]
4: Symbol: [ in scope 1 f of type bool]
5: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(5:main) }
Scope 1: {(0:b) (1:c) (2:d) (3:e) (4:f) }

---------------------------------------------------
Parsing: "void main(){int a; a=1; }"

AST pretty:
int a 
a=1

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Literal: 1 [int Rvalue]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }

---------------------------------------------------
Parsing: "void main(){int a; a=(1+2+3); }"

AST pretty:
int a 
a=( ( 1 + 2 ) + 3 )

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Op: +  [int Rvalue]
---Op: +  [int Rvalue]
----Literal: 1 [int Rvalue]
----Literal: 2 [int Rvalue]
---Literal: 3 [int Rvalue]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) }
Scope 1: {(0:a) }

---------------------------------------------------
Parsing: "void main(){int a b c; b=1; c=2; a=(1+b+c); }"
[err:19] Variable declarations must be separated with comma. at: "(){int a b" -> " c; b=1; c=2; a=(1+b+c); }"
[err:19] Variable declarations must be separated with comma. at: "{int a b c" -> "; b=1; c=2; a=(1+b+c); }"

AST pretty:
int a int b int c 
b=1
c=2
a=( ( 1 + b ) + c )

AST dump:
-int a int b int c 
-Assign
--b [int Lvalue Write Value]
--Literal: 1 [int Rvalue]
-Assign
--c [int Lvalue Write Value]
--Literal: 2 [int Rvalue]
-Assign
--a [int Lvalue Write Value]
--Op: +  [int Rvalue]
---Op: +  [int Rvalue]
----Literal: 1 [int Rvalue]
----b [int Lvalue Read Value]
---c [int Lvalue Read Value]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 1 b of type int]
2: Symbol: [ in scope 1 c of type int]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(0:a) (1:b) (2:c) }

---------------------------------------------------
Parsing: "void main(){ int a; int b; int a; }"
[err:15] Symbol already declared. at: " b; int a;" -> " }"
[err:31] function body empty at: "; int a; }" -> ""
AST not build (no functions) at: "; int a; }" -> ""
AST not build (fatal errors) at: "; int a; }" -> ""

---------------------------------------------------
Parsing: "void main(){ int a; if(1){int b;} }"
[err:21] if's condition is not a bool at: "nt a; if(1" -> "){int b;} }"

AST pretty:
int a 
if(1){
  int b 
  }

AST dump:
-int a 
-IfStmt:
--Cond: Literal: 1 [int Rvalue]
--Then:
---int b 


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 2 b of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(0:a) }
Scope 2: {(1:b) }

---------------------------------------------------
Parsing: "void main(){ int a; if(1){int b;}else{int c;} }"
[err:21] if's condition is not a bool at: "nt a; if(1" -> "){int b;}else{int c;} }"

AST pretty:
int a 
if(1){
  int b 
  }
else{
  int c 
  }

AST dump:
-int a 
-IfStmt:
--Cond: Literal: 1 [int Rvalue]
--Then:
---int b 
--Else:
---int c 


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 2 b of type int]
2: Symbol: [ in scope 3 c of type int]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(0:a) }
Scope 2: {(1:b) }
Scope 3: {(2:c) }

---------------------------------------------------
Parsing: "void main(){ int a; while(1 + 2){ int c; c = 1+2; } }"
[err:20] while's condition is not a bool at: " while(1 +" -> " 2){ int c; c = 1+2; } }"

AST pretty:
int a 
while(( 1 + 2 )){
  int c 
  c=( 1 + 2 )
  }

AST dump:
-int a 
-WhileStmt:
--Cond: Op: +  [int Rvalue]
---Literal: 1 [int Rvalue]
---Literal: 2 [int Rvalue]
--Body:
---int c 
---Assign
----c [int Lvalue Write Value]
----Op: +  [int Rvalue]
-----Literal: 1 [int Rvalue]
-----Literal: 2 [int Rvalue]


Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 2 c of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(0:a) }
Scope 2: {(1:c) }

---------------------------------------------------
Parsing: "void main(){ bool a, b; a = true; b = false; }"

AST pretty:
bool a bool b 
a=1
b=0

AST dump:
-bool a bool b 
-Assign
--a [bool Lvalue Write Value]
--Literal: 1 [bool Rvalue]
-Assign
--b [bool Lvalue Write Value]
--Literal: 0 [bool Rvalue]

Declaration Table:
0: Symbol: [ in scope 1 a of type bool]
1: Symbol: [ in scope 1 b of type bool]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(0:a) (1:b) }

---------------------------------------------------
Parsing: "void main(){ int* a; int* b; }"

AST pretty:
int* a 
int* b 

AST dump:
-int* a 
-int* b 

Declaration Table:
0: Symbol: [ in scope 1 a of type int*]
1: Symbol: [ in scope 1 b of type int*]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(0:a) (1:b) }

---------------------------------------------------
Parsing: "void main(){ int* a; int b, c; b = 2; a = &b; c = *a; }"

AST pretty:
int* a 
int b int c 
b=2
a=@b
c=*a

AST dump:
-int* a 
-int b int c 
-Assign
--b [int Lvalue Write Value]
--Literal: 2 [int Rvalue]
-Assign
--a [int* Lvalue Write Value]
--@ [int* Lvalue]
---b [int Lvalue Read Address]
-Assign
--c [int Lvalue Write Value]
--* [int Lvalue Read]
---a [int* Lvalue Read Value]

Declaration Table:
0: Symbol: [ in scope 1 a of type int*]
1: Symbol: [ in scope 1 b of type int]
2: Symbol: [ in scope 1 c of type int]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(0:a) (1:b) (2:c) }

---------------------------------------------------
Parsing: "void main(){int a; a= 2;} void f(){bool a; a=3;}"
[err:18] Incompatible types in assignment: bool to int at: "{bool a; a" -> "=3;}"

AST pretty:
int a 
a=2
bool a 
a=3

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Literal: 2 [int Rvalue]
-bool a 
-Assign
--a [bool Lvalue Write Value]
--Literal: 3 [int Rvalue]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]
2: Symbol: [ in scope 2 a of type bool]
3: Symbol: [ in scope 0 f of type function: ()->void]

Scopes of module:
Scope 0: {(1:main) (3:f) }
Scope 1: {(0:a) }
Scope 2: {(2:a) }


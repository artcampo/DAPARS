Grammar:
PROG -> E  init 
E -> T E' 
E' -> + T E' 
E' -> - T E' 
E' -> {empty} 
T -> F T' 
T' -> * F T' 
T' -> / F T' 
T' -> {empty} 
F -> ( E ) 
F -> {num} 
F -> {nam} 

---------------------------------------------------
Parsing: "void main(){int a;a=1;a=2;a=3; }"

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value Nmemb]
--[Lit] 1 [int Rvalue]
-[Asgst] 
--[Var] a [int Lvalue Write Value Nmemb]
--[Lit] 2 [int Rvalue]
-[Asgst] 
--[Var] a [int Lvalue Write Value Nmemb]
--[Lit] 3 [int Rvalue]


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }

---------------------------------------------------
Parsing: "void main(){int a;a=2+3+4; }"

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value Nmemb]
--Op: +  [int Rvalue]
---Op: +  [int Rvalue]
----[Lit] 2 [int Rvalue]
----[Lit] 3 [int Rvalue]
---[Lit] 4 [int Rvalue]


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }


---------------------------------------------------
Parsing: "void main(){int a;a=2++3+4; }"
Expecting numerical or lpar at: "nt a;a=2++" -> "3+4; }"
ResolveMemberTypes failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a
--Op: + 
---Op: + 
----[Lit] 2
----[Lit] 3
---[Lit] 4


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }


---------------------------------------------------
Parsing: "void main(){int a;a=1+2;a=3+4; }"

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value Nmemb]
--Op: +  [int Rvalue]
---[Lit] 1 [int Rvalue]
---[Lit] 2 [int Rvalue]
-[Asgst] 
--[Var] a [int Lvalue Write Value Nmemb]
--Op: +  [int Rvalue]
---[Lit] 3 [int Rvalue]
---[Lit] 4 [int Rvalue]


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }


---------------------------------------------------
Parsing: "void main(){int a;a=1+2;a=3+4;a=5+6; }"

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value Nmemb]
--Op: +  [int Rvalue]
---[Lit] 1 [int Rvalue]
---[Lit] 2 [int Rvalue]
-[Asgst] 
--[Var] a [int Lvalue Write Value Nmemb]
--Op: +  [int Rvalue]
---[Lit] 3 [int Rvalue]
---[Lit] 4 [int Rvalue]
-[Asgst] 
--[Var] a [int Lvalue Write Value Nmemb]
--Op: +  [int Rvalue]
---[Lit] 5 [int Rvalue]
---[Lit] 6 [int Rvalue]


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }


Grammar:
PROG -> E  init 
E -> T E' 
E' -> + T E' 
E' -> - T E' 
E' -> {empty} 
T -> F T' 
T' -> * F T' 
T' -> / F T' 
T' -> {empty} 
F -> ( E ) 
F -> {num} 
F -> {nam} 

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3;} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3;} }"
TypeCheck failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value]
--[Lit] 1 [int Rvalue]
-IfStmt:
--Cond: [Lit] 2 [int Rvalue]
--Then:
---[Asgst] 
----[Var] a [int Lvalue Write Value]
----[Lit] 3 [int Rvalue]



Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }
Scope 2: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3;} a=4; }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3;} a=4; }"
TypeCheck failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value]
--[Lit] 1 [int Rvalue]
-IfStmt:
--Cond: [Lit] 2 [int Rvalue]
--Then:
---[Asgst] 
----[Var] a [int Lvalue Write Value]
----[Lit] 3 [int Rvalue]

-[Asgst] 
--[Var] a [int Lvalue Write Value]
--[Lit] 4 [int Rvalue]


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }
Scope 2: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3+4+5;} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3+4+5;} }"
TypeCheck failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value]
--[Lit] 1 [int Rvalue]
-IfStmt:
--Cond: [Lit] 2 [int Rvalue]
--Then:
---[Asgst] 
----[Var] a [int Lvalue Write Value]
----Op: +  [int Rvalue]
-----Op: +  [int Rvalue]
------[Lit] 3 [int Rvalue]
------[Lit] 4 [int Rvalue]
-----[Lit] 5 [int Rvalue]



Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }
Scope 2: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3+4+5;} a=6; }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3+4+5;} a=6; }"
TypeCheck failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value]
--[Lit] 1 [int Rvalue]
-IfStmt:
--Cond: [Lit] 2 [int Rvalue]
--Then:
---[Asgst] 
----[Var] a [int Lvalue Write Value]
----Op: +  [int Rvalue]
-----Op: +  [int Rvalue]
------[Lit] 3 [int Rvalue]
------[Lit] 4 [int Rvalue]
-----[Lit] 5 [int Rvalue]

-[Asgst] 
--[Var] a [int Lvalue Write Value]
--[Lit] 6 [int Rvalue]


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }
Scope 2: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){if(3){a=4;if(5){a=6;}}} }"
[err:21] if's condition is not a bool at: "){a=4;if(5" -> "){a=6;}}} }"
[err:21] if's condition is not a bool at: "if(2){if(3" -> "){a=4;if(5){a=6;}}} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){if(3){a=4;if(5){a=6;}}} }"
TypeCheck failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value]
--[Lit] 1 [int Rvalue]
-IfStmt:
--Cond: [Lit] 2 [int Rvalue]
--Then:
---IfStmt:
----Cond: [Lit] 3 [int Rvalue]
----Then:
-----[Asgst] 
------[Var] a [int Lvalue Write Value]
------[Lit] 4 [int Rvalue]
-----IfStmt:
------Cond: [Lit] 5 [int Rvalue]
------Then:
-------[Asgst] 
--------[Var] a [int Lvalue Write Value]
--------[Lit] 6 [int Rvalue]





Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }
Scope 2: {}
Scope 3: {}
Scope 4: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){if(3){a=4+5;if(6){a=7+8;}}} }"
[err:21] if's condition is not a bool at: "a=4+5;if(6" -> "){a=7+8;}}} }"
[err:21] if's condition is not a bool at: "if(2){if(3" -> "){a=4+5;if(6){a=7+8;}}} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){if(3){a=4+5;if(6){a=7+8;}}} }"
TypeCheck failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value]
--[Lit] 1 [int Rvalue]
-IfStmt:
--Cond: [Lit] 2 [int Rvalue]
--Then:
---IfStmt:
----Cond: [Lit] 3 [int Rvalue]
----Then:
-----[Asgst] 
------[Var] a [int Lvalue Write Value]
------Op: +  [int Rvalue]
-------[Lit] 4 [int Rvalue]
-------[Lit] 5 [int Rvalue]
-----IfStmt:
------Cond: [Lit] 6 [int Rvalue]
------Then:
-------[Asgst] 
--------[Var] a [int Lvalue Write Value]
--------Op: +  [int Rvalue]
---------[Lit] 7 [int Rvalue]
---------[Lit] 8 [int Rvalue]





Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }
Scope 2: {}
Scope 3: {}
Scope 4: {}

---------------------------------------------------
Parsing: "void main(){int a;a=1; if(2){a=3;}if(4){a=5;}else{a=6;} }"
[err:21] if's condition is not a bool at: ";a=1; if(2" -> "){a=3;}if(4){a=5;}else{a=6;} }"
[err:21] if's condition is not a bool at: "{a=3;}if(4" -> "){a=5;}else{a=6;} }"
TypeCheck failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value]
--[Lit] 1 [int Rvalue]
-IfStmt:
--Cond: [Lit] 2 [int Rvalue]
--Then:
---[Asgst] 
----[Var] a [int Lvalue Write Value]
----[Lit] 3 [int Rvalue]

-IfStmt:
--Cond: [Lit] 4 [int Rvalue]
--Then:
---[Asgst] 
----[Var] a [int Lvalue Write Value]
----[Lit] 5 [int Rvalue]
--Else:
---[Asgst] 
----[Var] a [int Lvalue Write Value]
----[Lit] 6 [int Rvalue]



Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }
Scope 2: {}
Scope 3: {}
Scope 4: {}

---------------------------------------------------
Parsing: "void main(){int a; int b; bool c; }"

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[VDec] int b 
-[VDec] bool c 


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 1 b of type int]
3: Symbol: [ in scope 1 c of type bool]
4: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(4:main) }
Scope 1: {(1:a) (2:b) (3:c) }

---------------------------------------------------
Parsing: "void main(){int b, c, d; bool e f; }"
[err:19] Variable declarations must be separated with comma. at: "; bool e f" -> "; }"
ResolveMemberTypes failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int b 
[VDec] int c 
[VDec] int d 
-[VDec] bool e 
[VDec] bool f 


Declaration Table:
1: Symbol: [ in scope 1 b of type int]
2: Symbol: [ in scope 1 c of type int]
3: Symbol: [ in scope 1 d of type int]
4: Symbol: [ in scope 1 e of type bool]
5: Symbol: [ in scope 1 f of type bool]
6: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(6:main) }
Scope 1: {(1:b) (2:c) (3:d) (4:e) (5:f) }

---------------------------------------------------
Parsing: "void main(){int a; a=1; }"

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value Nmemb]
--[Lit] 1 [int Rvalue]


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }

---------------------------------------------------
Parsing: "void main(){int a; a=(1+2+3); }"

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value Nmemb]
--Op: +  [int Rvalue]
---Op: +  [int Rvalue]
----[Lit] 1 [int Rvalue]
----[Lit] 2 [int Rvalue]
---[Lit] 3 [int Rvalue]


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) }
Scope 1: {(1:a) }

---------------------------------------------------
Parsing: "void main(){int a b c; b=1; c=2; a=(1+b+c); }"
[err:19] Variable declarations must be separated with comma. at: "(){int a b" -> " c; b=1; c=2; a=(1+b+c); }"
[err:19] Variable declarations must be separated with comma. at: "{int a b c" -> "; b=1; c=2; a=(1+b+c); }"
ResolveMemberTypes failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
[VDec] int b 
[VDec] int c 
-[Asgst] 
--[Var] b
--[Lit] 1
-[Asgst] 
--[Var] c
--[Lit] 2
-[Asgst] 
--[Var] a
--Op: + 
---Op: + 
----[Lit] 1
----[Var] b
---[Var] c


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 1 b of type int]
3: Symbol: [ in scope 1 c of type int]
4: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(4:main) }
Scope 1: {(1:a) (2:b) (3:c) }

---------------------------------------------------
Parsing: "void main(){ int a; int b; int a; }"
[err:15] Symbol already declared. at: " b; int a;" -> " }"
[err:31] function body empty at: "; int a; }" -> ""
AST not build (no functions) at: "; int a; }" -> ""
AST not build (fatal errors) at: "; int a; }" -> ""

---------------------------------------------------
Parsing: "void main(){ int a; if(1){int b;} }"
[err:21] if's condition is not a bool at: "nt a; if(1" -> "){int b;} }"
TypeCheck failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-IfStmt:
--Cond: [Lit] 1 [int Rvalue]
--Then:
---[VDec] int b 



Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 2 b of type int]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(1:a) }
Scope 2: {(2:b) }

---------------------------------------------------
Parsing: "void main(){ int a; if(1){int b;}else{int c;} }"
[err:21] if's condition is not a bool at: "nt a; if(1" -> "){int b;}else{int c;} }"
TypeCheck failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-IfStmt:
--Cond: [Lit] 1 [int Rvalue]
--Then:
---[VDec] int b 
--Else:
---[VDec] int c 



Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 2 b of type int]
3: Symbol: [ in scope 3 c of type int]
4: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(4:main) }
Scope 1: {(1:a) }
Scope 2: {(2:b) }
Scope 3: {(3:c) }

---------------------------------------------------
Parsing: "void main(){ int a; while(1 + 2){ int c; c = 1+2; } }"
[err:20] while's condition is not a bool at: " while(1 +" -> " 2){ int c; c = 1+2; } }"
TypeCheck failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-WhileStmt:
--Cond: Op: +  [int Rvalue]
---[Lit] 1 [int Rvalue]
---[Lit] 2 [int Rvalue]
--Body:
---[VDec] int c 
---[Asgst] 
----[Var] c [int Lvalue Write Value]
----Op: +  [int Rvalue]
-----[Lit] 1 [int Rvalue]
-----[Lit] 2 [int Rvalue]



Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 2 c of type int]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(1:a) }
Scope 2: {(2:c) }

---------------------------------------------------
Parsing: "void main(){ bool a, b; a = true; b = false; }"

AST dump:
[FDef] FuncDef: main
-[VDec] bool a 
[VDec] bool b 
-[Asgst] 
--[Var] a [bool Lvalue Write Value Nmemb]
--[Lit] 1 [bool Rvalue]
-[Asgst] 
--[Var] b [bool Lvalue Write Value Nmemb]
--[Lit] 0 [bool Rvalue]


Declaration Table:
1: Symbol: [ in scope 1 a of type bool]
2: Symbol: [ in scope 1 b of type bool]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(1:a) (2:b) }

---------------------------------------------------
Parsing: "void main(){ int* a; int* b; }"

AST dump:
[FDef] FuncDef: main
-[VDec] int* a 
-[VDec] int* b 


Declaration Table:
1: Symbol: [ in scope 1 a of type int*]
2: Symbol: [ in scope 1 b of type int*]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(1:a) (2:b) }

---------------------------------------------------
Parsing: "void main(){ int* a; int b, c; b = 2; a = &b; c = *a; }"

AST dump:
[FDef] FuncDef: main
-[VDec] int* a 
-[VDec] int b 
[VDec] int c 
-[Asgst] 
--[Var] b [int Lvalue Write Value Nmemb]
--[Lit] 2 [int Rvalue]
-[Asgst] 
--[Var] a [int* Lvalue Write Value Nmemb]
--[Refop] @ [int* Lvalue]
---[Var] b [int Lvalue Read Address Nmemb]
-[Asgst] 
--[Var] c [int Lvalue Write Value Nmemb]
--[Derop] * [int Lvalue Read]
---[Var] a [int* Lvalue Read Value Nmemb]


Declaration Table:
1: Symbol: [ in scope 1 a of type int*]
2: Symbol: [ in scope 1 b of type int]
3: Symbol: [ in scope 1 c of type int]
4: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(4:main) }
Scope 1: {(1:a) (2:b) (3:c) }

---------------------------------------------------
Parsing: "void main(){int a; a= 2;} void f(){bool a; a=3;}"
[err:18] Incompatible types in assignment: bool to int at: "{bool a; a" -> "=3;}"
TypeCheck failed. 

AST dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Asgst] 
--[Var] a [int Lvalue Write Value]
--[Lit] 2 [int Rvalue]
[FDef] FuncDef: f
-[VDec] bool a 
-[Asgst] 
--[Var] a [bool Lvalue Write Value]
--[Lit] 3 [int Rvalue]


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]
3: Symbol: [ in scope 2 a of type bool]
4: Symbol: [ in scope 0 f of type function: ()->void]

Scopes of module:
Scope 0: {(2:main) (4:f) }
Scope 1: {(1:a) }
Scope 2: {(3:a) }

---------------------------------------------------
Parsing: "class O1{} void main(){ O1 a;}"

AST dump:
[CDef] ClassDef: O1
[FDef] FuncDef: main
-[VDec] O1 a 


Declaration Table:
1: Symbol: [ in scope 0 O1 of type O1]
2: Symbol: [ in scope 2 a of type O1]
3: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(1:O1) (3:main) }
HScope of O1 1: {}
Scope 2: {(2:a) }

---------------------------------------------------
Parsing: "class O1{int a;} void main(){ O1 inst; int b; b = inst.a;}"

AST dump:
[CDef] ClassDef: O1
-[VDec] int a
[FDef] FuncDef: main
-[VDec] O1 inst 
-[VDec] int b 
-[Asgst] 
--[Var] b [int Lvalue Write Value Nmemb]
--[Dotop] inst.a [int Memb]
---[Var] inst [O1 Lvalue Read Address Nmemb]
---[Vnam] a


Declaration Table:
2: Symbol: [ in scope 0 O1 of type O1]
3: Symbol: [ in scope 2 inst of type O1]
4: Symbol: [ in scope 2 b of type int]
5: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:O1) (5:main) }
HScope of O1 1: {(1:a) }
Scope 2: {(3:inst) (4:b) }

---------------------------------------------------
Parsing: "class O1{int a;} class O2{ O1 o1;} void main(){ O2 inst; int b; b = inst.o1.a;}"

AST dump:
[CDef] ClassDef: O1
-[VDec] int a
[CDef] ClassDef: O2
-[VDec] O1 o1
[FDef] FuncDef: main
-[VDec] O2 inst 
-[VDec] int b 
-[Asgst] 
--[Var] b [int Lvalue Write Value Nmemb]
--[Dotop] inst.o1.a [int Memb]
---[Dotop] inst.o1 [O1 Memb]
----[Var] inst [O2 Lvalue Read Address Nmemb]
----[Vnam] o1
---[Vnam] a


Declaration Table:
2: Symbol: [ in scope 0 O1 of type O1]
4: Symbol: [ in scope 0 O2 of type O2]
5: Symbol: [ in scope 3 inst of type O2]
6: Symbol: [ in scope 3 b of type int]
7: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:O1) (4:O2) (7:main) }
HScope of O1 1: {(1:a) }
HScope of O2 2: {(3:o1) }
Scope 3: {(5:inst) (6:b) }

---------------------------------------------------
Parsing: "class O1{int f(int a, int b){int c; c = a+b; return c;}} void main(){ O1 inst; int b; b = inst.f(1,2);}"

AST dump:
[CDef] ClassDef: O1
-[FDef] FuncDef: f
--[VDec] int c 
--[Asgst] 
---[Var] c [int Lvalue Write Value Nmemb]
---Op: +  [int Rvalue]
----[Var] a [int Lvalue Read Value Nmemb]
----[Var] b [int Lvalue Read Value Nmemb]
--[Retst] Return (c)
---[Var] c [int Lvalue Read Value Nmemb]

[FDef] FuncDef: main
-[VDec] O1 inst 
-[VDec] int b 
-[Asgst] 
--[Var] b [int Lvalue Write Value Nmemb]
--[Fret] FuncRet: int [int Rvalue Nmemb]
---[Fcal] FuncCall: inst.f [function: (int, int)->int]
----[Dotop] inst.f [function: (int, int)->int Memb]
-----[Var] inst [O1 Read Address Nmemb]
-----[Vnam] f
----[Lit] 1 [int]
----[Lit] 2 [int]


Declaration Table:
1: Symbol: [ in scope 2 a of type int]
2: Symbol: [ in scope 2 b of type int]
3: Symbol: [ in scope 2 c of type int]
5: Symbol: [ in scope 0 O1 of type O1]
6: Symbol: [ in scope 3 inst of type O1]
7: Symbol: [ in scope 3 b of type int]
8: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(5:O1) (8:main) }
HScope of O1 1: {(4:f) }
Scope 2: {(1:a) (2:b) (3:c) }
Scope 3: {(6:inst) (7:b) }

---------------------------------------------------
Parsing: "class O1{int f(int a){return a + a_;} int a_;} void main(){ O1 inst; }"

AST dump:
[CDef] ClassDef: O1
-[VDec] int a_
-[FDef] FuncDef: f
--[Retst] Return ( + )
---Op: +  [int Rvalue]
----[Var] a [int Lvalue Read Value Nmemb]
----[Var] a_ [int Lvalue Read Value Memb]

[FDef] FuncDef: main
-[VDec] O1 inst 


Declaration Table:
1: Symbol: [ in scope 2 a of type int]
4: Symbol: [ in scope 0 O1 of type O1]
5: Symbol: [ in scope 3 inst of type O1]
6: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(4:O1) (6:main) }
HScope of O1 1: {(2:f) (3:a_) }
Scope 2: {(1:a) }
Scope 3: {(5:inst) }

---------------------------------------------------
Parsing: "class O1{int f(){return 1;} } class O2{int g(){return inst_.f() + 1;} O1 inst_; } void main(){ O2 inst; }"

AST dump:
[CDef] ClassDef: O1
-[FDef] FuncDef: f
--[Retst] Return (1)
---[Lit] 1 [int Rvalue]

[CDef] ClassDef: O2
-[VDec] O1 inst_
-[FDef] FuncDef: g
--[Retst] Return ( + )
---Op: +  [int Rvalue]
----[Fret] FuncRet: int [int Rvalue Nmemb]
-----[Fcal] FuncCall: inst_.f [function: ()->int]
------[Dotop] inst_.f [function: ()->int Memb]
-------[Var] inst_ [O1 Read Address Memb]
-------[Vnam] f
----[Lit] 1 [int Rvalue]

[FDef] FuncDef: main
-[VDec] O2 inst 


Declaration Table:
2: Symbol: [ in scope 0 O1 of type O1]
5: Symbol: [ in scope 0 O2 of type O2]
6: Symbol: [ in scope 5 inst of type O2]
7: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:O1) (5:O2) (7:main) }
HScope of O1 1: {(1:f) }
Scope 2: {}
HScope of O2 3: {(3:g) (4:inst_) }
Scope 4: {}
Scope 5: {(6:inst) }

---------------------------------------------------
Parsing: "class O1{int f(){return g();} int g(){return 1;} } void main(){ O1 inst;}"

AST dump:
[CDef] ClassDef: O1
-[FDef] FuncDef: f
--[Retst] Return (FuncRet: int)
---[Fret] FuncRet: int [int Rvalue Memb]
----[Fcal] FuncCall: g [function: ()->int]
-----[Var] g [function: ()->int Read Value Memb]

-[FDef] FuncDef: g
--[Retst] Return (1)
---[Lit] 1 [int Rvalue]

[FDef] FuncDef: main
-[VDec] O1 inst 


Declaration Table:
3: Symbol: [ in scope 0 O1 of type O1]
4: Symbol: [ in scope 4 inst of type O1]
5: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(3:O1) (5:main) }
HScope of O1 1: {(1:f) (2:g) }
Scope 2: {}
Scope 3: {}
Scope 4: {(4:inst) }

---------------------------------------------------
Parsing: "class A{int a;} class B : A{int b;} void main(){ B inst;}"

AST dump:
[CDef] ClassDef: A
-[VDec] int a
[CDef] ClassDef: B
-[VDec] int b
[FDef] FuncDef: main
-[VDec] B inst 


Declaration Table:
2: Symbol: [ in scope 0 A of type A]
4: Symbol: [ in scope 0 B of type B]
5: Symbol: [ in scope 3 inst of type B]
6: Symbol: [ in scope 0 main of type function: ()->void]

Scopes of module:
Scope 0: {(2:A) (4:B) (6:main) }
HScope of A 1: {(1:a) }
HScope of B 2: {(3:b) }
Scope 3: {(5:inst) }


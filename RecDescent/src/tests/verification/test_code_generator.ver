Grammar:
PROG -> E  init 
E -> T E' 
E' -> + T E' 
E' -> - T E' 
E' -> {empty} 
T -> F T' 
T' -> * F T' 
T' -> / F T' 
T' -> {empty} 
F -> ( E ) 
F -> {num} 
F -> {nam} 

---------------------------------------------------
Parsing: "void main(){int a; a= 2;} void f(int p1){int a; a=p1;}"

Scopes of module:
Scope 0: {(1:main) (4:f) }
Scope 1: {(0:a) }
Scope 2: {(2:p1) (3:a) }

Symbol: [ in scope 2 p1 of type int] to offset: -2

AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Literal: 2 [int Rvalue]
-int a 
-Assign
--a [int Lvalue Write Value]
--p1 [int Lvalue Read Value]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]
2: Symbol: [ in scope 2 p1 of type int]
3: Symbol: [ in scope 2 a of type int]
4: Symbol: [ in scope 0 f of type function: ()->void]
in f: main with label: MainDSUsing label: MainDSin f: f with label: arp_fUsing label: arp_f
IR dump:
0: %0 = LoadI(2)
1: store %0 to [MainDS:a]
2: %2 = Load [arp_f:p1]
3: store %2 to [arp_f:a]


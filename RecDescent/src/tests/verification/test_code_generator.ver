Grammar:
PROG -> E  init 
E -> T E' 
E' -> + T E' 
E' -> - T E' 
E' -> {empty} 
T -> F T' 
T' -> * F T' 
T' -> / F T' 
T' -> {empty} 
F -> ( E ) 
F -> {num} 
F -> {nam} 

---------------------------------------------------
Parsing: "void main(){int a,b,c; while(true){b=2+3;} c=3+4; }"

Scopes of module:
Scope 0: {(4:main) }
Scope 1: {(1:a) (2:b) (3:c) }
Scope 2: {}


AST fully decorated dump:
[FDef] FuncDef: main
-[VDec] int a 
[VDec] int b 
[VDec] int c 
-WhileStmt:
--Cond: [Lit] 1 [bool Rvalue]
--Body:
---[Assgn] 
----[Var] b [int Lvalue Write Value Nmemb]
----Op: +  [int Rvalue]
-----[Lit] 2 [int Rvalue]
-----[Lit] 3 [int Rvalue]

--[Assgn] 
---[Var] c [int Lvalue Write Value Nmemb]
---Op: +  [int Rvalue]
----[Lit] 3 [int Rvalue]
----[Lit] 4 [int Rvalue]


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 1 b of type int]
3: Symbol: [ in scope 1 c of type int]
4: Symbol: [ in scope 0 main of type function: ()->void]

IR dump:
LT entry_main
0: %0 = LoadI(1)
1: JumpCondTrue %0 to:3
2: JumpCondFalse %0 to:8
3: %1 = LoadI(2)
4: %2 = LoadI(3)
5: %3 = %1 + %2
6: store %3 to [LT MainDS:b 1]
7: JumpCondFalse %0 to:0
8: %5 = LoadI(3)
9: %6 = LoadI(4)
10: %7 = %5 + %6
11: store %7 to [LT MainDS:c 2]
12: ReturnMain

---------------------------------------------------
Parsing: "void main(){ int a, b; if(true){int c; a=2+3;} else{ int d, e,f; d = 4; } int g; b=5+6; }"

Scopes of module:
Scope 0: {(8:main) }
Scope 1: {(1:a) (2:b) (7:g) }
Scope 2: {(3:c) }
Scope 3: {(4:d) (5:e) (6:f) }


AST fully decorated dump:
[FDef] FuncDef: main
-[VDec] int a 
[VDec] int b 
-IfStmt:
--Cond: [Lit] 1 [bool Rvalue]
--Then:
---[VDec] int c 
---[Assgn] 
----[Var] a [int Lvalue Write Value Nmemb]
----Op: +  [int Rvalue]
-----[Lit] 2 [int Rvalue]
-----[Lit] 3 [int Rvalue]
--Else:
---[VDec] int d 
[VDec] int e 
[VDec] int f 
---[Assgn] 
----[Var] d [int Lvalue Write Value Nmemb]
----[Lit] 4 [int Rvalue]

-[VDec] int g 
-[Assgn] 
--[Var] b [int Lvalue Write Value Nmemb]
--Op: +  [int Rvalue]
---[Lit] 5 [int Rvalue]
---[Lit] 6 [int Rvalue]


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 1 b of type int]
3: Symbol: [ in scope 2 c of type int]
4: Symbol: [ in scope 3 d of type int]
5: Symbol: [ in scope 3 e of type int]
6: Symbol: [ in scope 3 f of type int]
7: Symbol: [ in scope 1 g of type int]
8: Symbol: [ in scope 0 main of type function: ()->void]

IR dump:
LT entry_main
0: %0 = LoadI(1)
1: JumpCondTrue %0 to:3
2: JumpCondFalse %0 to:8
3: %1 = LoadI(2)
4: %2 = LoadI(3)
5: %3 = %1 + %2
6: store %3 to [LT MainDS:a 0]
7: JumpIncond11
8: %5 = LoadI(4)
9: store %5 to [LT MainDS:d 2]
10: JumpIncond11
11: %7 = LoadI(5)
12: %8 = LoadI(6)
13: %9 = %7 + %8
14: store %9 to [LT MainDS:b 1]
15: ReturnMain

---------------------------------------------------
Parsing: "void main(){int a,b; int* p; a=*p; b=2; p = &b; a = b + *p;}"

Scopes of module:
Scope 0: {(4:main) }
Scope 1: {(1:a) (2:b) (3:p) }


AST fully decorated dump:
[FDef] FuncDef: main
-[VDec] int a 
[VDec] int b 
-[VDec] int* p 
-[Assgn] 
--[Var] a [int Lvalue Write Value Nmemb]
--[Derop] * [int Lvalue Read]
---[Var] p [int* Lvalue Read Value Nmemb]
-[Assgn] 
--[Var] b [int Lvalue Write Value Nmemb]
--[Lit] 2 [int Rvalue]
-[Assgn] 
--[Var] p [int* Lvalue Write Value Nmemb]
--[Refop] @ [int* Lvalue]
---[Var] b [int Lvalue Read Address Nmemb]
-[Assgn] 
--[Var] a [int Lvalue Write Value Nmemb]
--Op: +  [int Rvalue]
---[Var] b [int Lvalue Read Value Nmemb]
---[Derop] * [int Lvalue Read]
----[Var] p [int* Lvalue Read Value Nmemb]


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 1 b of type int]
3: Symbol: [ in scope 1 p of type int*]
4: Symbol: [ in scope 0 main of type function: ()->void]

IR dump:
LT entry_main
0: %0 = Load [LT MainDS:p 2]
1: %1 = Load [ %0]
2: store %1 to [LT MainDS:a 0]
3: %3 = LoadI(2)
4: store %3 to [LT MainDS:b 1]
5: %5 = PtrElem( LT MainDS:b 1)
6: store %5 to [LT MainDS:p 2]
7: %7 = Load [LT MainDS:b 1]
8: %8 = Load [LT MainDS:p 2]
9: %9 = Load [ %8]
10: %10 = %7 + %9
11: store %10 to [LT MainDS:a 0]
12: ReturnMain

---------------------------------------------------
Parsing: "void main(){int a; a= 2;} void f(int p1){int a; a=p1;}"

Scopes of module:
Scope 0: {(2:main) (5:f) }
Scope 1: {(1:a) }
Scope 2: {(3:p1) (4:a) }


AST fully decorated dump:
[FDef] FuncDef: main
-[VDec] int a 
-[Assgn] 
--[Var] a [int Lvalue Write Value Nmemb]
--[Lit] 2 [int Rvalue]
[FDef] FuncDef: f
-[VDec] int a 
-[Assgn] 
--[Var] a [int Lvalue Write Value Nmemb]
--[Var] p1 [int Lvalue Read Value Nmemb]


Declaration Table:
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 main of type function: ()->void]
3: Symbol: [ in scope 2 p1 of type int]
4: Symbol: [ in scope 2 a of type int]
5: Symbol: [ in scope 0 f of type function: (int)->void]

IR dump:
LT entry_main
0: %0 = LoadI(2)
1: store %0 to [LT MainDS:a 0]
2: ReturnMain
LT entry_f
0: %0 = Load [RT arp_f:p1 -2]
1: store %0 to [RT arp_f:a 0]
2: Return

---------------------------------------------------
Parsing: "int f(int p1){int a; a=p1; return a;} void main(){int a; a=f(2);}"

Scopes of module:
Scope 0: {(3:f) (5:main) }
Scope 1: {(1:p1) (2:a) }
Scope 2: {(4:a) }


AST fully decorated dump:
[FDef] FuncDef: f
-[VDec] int a 
-[Assgn] 
--[Var] a [int Lvalue Write Value Nmemb]
--[Var] p1 [int Lvalue Read Value Nmemb]
-[Retst] Return (a)
--[Var] a [int Lvalue Read Value Nmemb]
[FDef] FuncDef: main
-[VDec] int a 
-[Assgn] 
--[Var] a [int Lvalue Write Value Nmemb]
--[Fret] FuncRet: int [int Rvalue Nmemb]
---[Fcal] FuncCall: f [function: (int)->int]
----[Var] f [function: (int)->int Read Value Nmemb]
----[Lit] 2 [int]


Declaration Table:
1: Symbol: [ in scope 1 p1 of type int]
2: Symbol: [ in scope 1 a of type int]
3: Symbol: [ in scope 0 f of type function: (int)->int]
4: Symbol: [ in scope 2 a of type int]
5: Symbol: [ in scope 0 main of type function: ()->void]

IR dump:
LT entry_main
0: %0 = LoadI(2)
1: SetPar( %0)
2: call [LT entry_f: 0]
3: %1 = GetRetVal()
4: store %1 to [LT MainDS:a 0]
5: ReturnMain
LT entry_f
0: %0 = Load [RT arp_f:p1 -2]
1: store %0 to [RT arp_f:a 0]
2: %2 = Load [RT arp_f:a 0]
3: Return

---------------------------------------------------
Parsing: "class O1{int a_; int b_; int f(){return a_ + g();} int g(){return b_;} } void main(){O1 inst; int a; a = inst.f() + inst.a_;}"

Scopes of module:
Scope 0: {(5:O1) (8:main) }
HScope of O1 1: {(1:a_) (2:b_) (3:f) (4:g) }
Scope 2: {}
Scope 3: {}
Scope 4: {(6:inst) (7:a) }


AST fully decorated dump:
[CDef] O1 [O1]
-[VDec] int a_
-[VDec] int b_
-[FDef] FuncDef: f
--[Retst] Return ( + )
---Op: +  [int Rvalue]
----[Var] a_ [int Lvalue Read Value Memb]
----[Fret] FuncRet: int [int Rvalue Memb]
-----[Fcal] FuncCall: g [function: ()->int]
------[Var] g [function: ()->int Read Value Memb]

-[FDef] FuncDef: g
--[Retst] Return (b_)
---[Var] b_ [int Lvalue Read Value Memb]

[FDef] FuncDef: main
-[VDec] O1 inst 
-[VDec] int a 
-[Assgn] 
--[Var] a [int Lvalue Write Value Nmemb]
--Op: +  [int Rvalue]
---[Fret] FuncRet: int [int Rvalue Nmemb]
----[Fcal] FuncCall: inst.f [function: ()->int]
-----[Dotop] inst.f [function: ()->int Memb]
------[Var] inst [O1 Read Address Nmemb]
------[Vnam] f
---[Dotop] inst.a_ [int Lvalue Memb]
----[Var] inst [O1 Lvalue Read Address Nmemb]
----[Vnam] a_


Declaration Table:
5: Symbol: [ in scope 0 O1 of type O1]
6: Symbol: [ in scope 4 inst of type O1]
7: Symbol: [ in scope 4 a of type int]
8: Symbol: [ in scope 0 main of type function: ()->void]

IR dump:
LT entry_O1::f
0: %0 = Load [RT this_O1:a_ 0]
1: %1 = Load [RT this_O1: 0]
2: SetPar( %1)
3: call [LT entry_O1::g: 0]
4: %2 = GetRetVal()
5: %3 = %0 + %2
6: Return
LT entry_O1::g
0: %0 = Load [RT this_O1:b_ 1]
1: Return
LT entry_main
0: %0 = PtrElem( LT MainDS:inst 0)
1: SetPar( %0)
2: call [LT entry_O1::f: 0]
3: %1 = GetRetVal()
4: %2 = PtrElem( LT MainDS:inst 0)
5: %3 = Load [ %2 + a_ 0]
6: %4 = %1 + %3
7: store %4 to [LT MainDS:a 2]
8: ReturnMain


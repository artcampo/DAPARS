Grammar:
PROG -> E  init 
E -> T E' 
E' -> + T E' 
E' -> - T E' 
E' -> {empty} 
T -> F T' 
T' -> * F T' 
T' -> / F T' 
T' -> {empty} 
F -> ( E ) 
F -> {num} 
F -> {nam} 

---------------------------------------------------
Parsing: "main(){ int a, b; if(true){a=2+3;} b=3+4; }"
Undo end
Undo end

AST dump:
-int a int b 
-IfStmt:
--Cond: Literal: 1 [bool Rvalue]
--Then:
---Assign
----a [int Lvalue]
----Op: +  [int Rvalue]
-----Literal: 2 [int Rvalue]
-----Literal: 3 [int Rvalue]

-Assign
--b [int Lvalue]
--Op: +  [int Rvalue]
---Literal: 3 [int Rvalue]
---Literal: 4 [int Rvalue]

IR dump:
0: r0 = LoadI of 1
1: JumpCondTrue reg:0 to:3
2: JumpCondFalse reg:0 to:7
3: r1 = LoadI of 2
4: r2 = LoadI of 3
5: r3 = Arith r1 + r2
6: JumpIncond7
7: r4 = LoadI of 3
8: r5 = LoadI of 4
9: r6 = Arith r4 + r5

---------------------------------------------------
Parsing: "main(){int a,b,c; while(true){b=2+3;} c=3+4; }"
Undo end
Undo end

AST dump:
-int a int b int c 
-WhileStmt:
--Cond: Literal: 1 [bool Rvalue]
--Body:
---Assign
----b [int Lvalue]
----Op: +  [int Rvalue]
-----Literal: 2 [int Rvalue]
-----Literal: 3 [int Rvalue]

--Assign
---c [int Lvalue]
---Op: +  [int Rvalue]
----Literal: 3 [int Rvalue]
----Literal: 4 [int Rvalue]

IR dump:
0: r0 = LoadI of 1
1: JumpCondTrue reg:0 to:3
2: JumpCondFalse reg:0 to:7
3: r1 = LoadI of 2
4: r2 = LoadI of 3
5: r3 = Arith r1 + r2
6: JumpCondFalse reg:0 to:0
7: r4 = LoadI of 3
8: r5 = LoadI of 4
9: r6 = Arith r4 + r5


Grammar:
PROG -> E  init 
E -> T E' 
E' -> + T E' 
E' -> - T E' 
E' -> {empty} 
T -> F T' 
T' -> * F T' 
T' -> / F T' 
T' -> {empty} 
F -> ( E ) 
F -> {num} 
F -> {nam} 

---------------------------------------------------
Parsing: "main(){int a,b,c; while(true){b=2+3;} c=3+4; }"
Scope 1: {0, a 1, b 2, c }
Scope 2: {}


IR dump:
0: %0 = LoadI(1)
1: JumpCondTrue %0 to:3
2: JumpCondFalse %0 to:7
3: %1 = LoadI(3)
4: %2 = %0 + %1
5: store %2 to [Main:b]
6: JumpCondFalse %0 to:0
7: %4 = LoadI(4)
8: %5 = %0 + %4
9: store %5 to [Main:c]

---------------------------------------------------
Parsing: "main(){ int a, b; if(true){int c; a=2+3;} else{ int d, e,f; d = 4; } int g; b=5+6; }"
Scope 1: {0, a 1, b 6, g }
Scope 2: {2, c }
Scope 3: {3, d 4, e 5, f }


IR dump:
0: %0 = LoadI(1)
1: JumpCondTrue %0 to:3
2: JumpCondFalse %0 to:7
3: %1 = LoadI(3)
4: %2 = %0 + %1
5: store %2 to [Main:a]
6: JumpIncond10
7: %4 = LoadI(4)
8: store %4 to [Main:d]
9: JumpIncond10
10: %6 = LoadI(6)
11: %7 = %0 + %6
12: store %7 to [Main:b]

---------------------------------------------------
Parsing: "main(){int a,b; int* p; a = 2; p = &a; *p = a + b; }"
Scope 1: {0, a 1, b 2, p }


IR dump:
0: %0 = LoadI(2)
1: store %0 to [Main:a]
2: %2 = Load [Main:a]
3: %3 = & %2
4: store %3 to [Main:p]
5: %5 = Load [Main:b]
6: %6 = %0 + %5
7: store %0 to [Main:p]
8: %8 = * %0

---------------------------------------------------
Parsing: "main(){int a,b; int* p; a=1; b=2; p = &b; a = b + *p; }"
Scope 1: {0, a 1, b 2, p }


IR dump:
0: %0 = LoadI(1)
1: store %0 to [Main:a]
2: %2 = LoadI(2)
3: store %2 to [Main:b]
4: %4 = Load [Main:b]
5: %5 = & %4
6: store %5 to [Main:p]
7: %7 = Load [Main:p]
8: %8 = * %7
9: %9 = %0 + %8
10: store %9 to [Main:a]


Grammar:
PROG -> E  init 
E -> T E' 
E' -> + T E' 
E' -> - T E' 
E' -> {empty} 
T -> F T' 
T' -> * F T' 
T' -> / F T' 
T' -> {empty} 
F -> ( E ) 
F -> {num} 
F -> {nam} 

---------------------------------------------------
Parsing: "void main(){int a,b,c; while(true){b=2+3;} c=3+4; }"

Scopes of module:
Scope 0: {(4:main) }
Scope 1: {(1:a) (2:b) (3:c) }
Scope 2: {}


IR dump:
0: %0 = LoadI(1)
1: JumpCondTrue %0 to:3
2: JumpCondFalse %0 to:8
3: %1 = LoadI(2)
4: %2 = LoadI(3)
5: %3 = %1 + %2
6: store %3 to [MainDS:b 1]
7: JumpCondFalse %0 to:0
8: %5 = LoadI(3)
9: %6 = LoadI(4)
10: %7 = %5 + %6
11: store %7 to [MainDS:c 2]
12: ReturnMain

---------------------------------------------------
Parsing: "void main(){ int a, b; if(true){int c; a=2+3;} else{ int d, e,f; d = 4; } int g; b=5+6; }"

Scopes of module:
Scope 0: {(8:main) }
Scope 1: {(1:a) (2:b) (7:g) }
Scope 2: {(3:c) }
Scope 3: {(4:d) (5:e) (6:f) }


IR dump:
0: %0 = LoadI(1)
1: JumpCondTrue %0 to:3
2: JumpCondFalse %0 to:8
3: %1 = LoadI(2)
4: %2 = LoadI(3)
5: %3 = %1 + %2
6: store %3 to [MainDS:a 0]
7: JumpIncond11
8: %5 = LoadI(4)
9: store %5 to [MainDS:d 2]
10: JumpIncond11
11: %7 = LoadI(5)
12: %8 = LoadI(6)
13: %9 = %7 + %8
14: store %9 to [MainDS:b 1]
15: ReturnMain

---------------------------------------------------
Parsing: "void main(){int a,b; int* p; a=*p; b=2; p = &b; a = b + *p;}"

Scopes of module:
Scope 0: {(4:main) }
Scope 1: {(1:a) (2:b) (3:p) }


IR dump:
0: %0 = Load [MainDS:p 2]
1: %1 = Load [ %0]
2: store %1 to [MainDS:a 0]
3: %3 = LoadI(2)
4: store %3 to [MainDS:b 1]
5: %5 = PtrElem( MainDS:b 1)
6: store %5 to [MainDS:p 2]
7: %7 = Load [MainDS:b 1]
8: %8 = Load [MainDS:p 2]
9: %9 = Load [ %8]
10: %10 = %7 + %9
11: store %10 to [MainDS:a 0]
12: ReturnMain

---------------------------------------------------
Parsing: "void main(){int a; a= 2;} void f(int p1){int a; a=p1;}"

Scopes of module:
Scope 0: {(2:main) (5:f) }
Scope 1: {(1:a) }
Scope 2: {(3:p1) (4:a) }


IR dump:
0: %0 = LoadI(2)
1: store %0 to [MainDS:a 0]
2: ReturnMain
3: %2 = Load [arp_f:p1 -2]
4: store %2 to [arp_f:a 0]
5: Return

---------------------------------------------------
Parsing: "int f(int p1){int a; a=p1; return a;} void main(){int a; a=f(2);}"

Scopes of module:
Scope 0: {(3:f) (5:main) }
Scope 1: {(1:p1) (2:a) }
Scope 2: {(4:a) }


IR dump:
0: %0 = LoadI(2)
1: SetPar( %0)
2: call [entry_f: 0]
3: %1 = GetRetVal()
4: store %1 to [MainDS:a 0]
5: ReturnMain
6: %3 = Load [arp_f:p1 -2]
7: store %3 to [arp_f:a 0]
8: %5 = Load [arp_f:a 0]
9: Return

---------------------------------------------------
Parsing: "class O1{int a_; int b_; int f(){return a_;} int g(){return b_;} } void main(){O1 inst; int a; a = inst.f() + inst.g();}"

Scopes of module:
Scope 0: {(5:O1) (8:main) }
HScope of O1 1: {(1:a_) (2:b_) (3:f) (4:g) }
Scope 2: {}
Scope 3: {}
Scope 4: {(6:inst) (7:a) }


IR dump:
0: call [: 0]
1: %0 = GetRetVal()
2: call [: 0]
3: %1 = GetRetVal()
4: %2 = %0 + %1
5: store %2 to [MainDS:a 1]
6: ReturnMain


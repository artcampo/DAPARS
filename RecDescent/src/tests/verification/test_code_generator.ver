Grammar:
PROG -> E  init 
E -> T E' 
E' -> + T E' 
E' -> - T E' 
E' -> {empty} 
T -> F T' 
T' -> * F T' 
T' -> / F T' 
T' -> {empty} 
F -> ( E ) 
F -> {num} 
F -> {nam} 

---------------------------------------------------
Parsing: "void main(){int a,b,c; while(true){b=2+3;} c=3+4; }"

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(0:a) (1:b) (2:c) }
Scope 2: {}


AST dump:
-int a int b int c 
-WhileStmt:
--Cond: Literal: 1 [bool Rvalue]
--Body:
---Assign
----b [int Lvalue Write Value]
----Op: +  [int Rvalue]
-----Literal: 2 [int Rvalue]
-----Literal: 3 [int Rvalue]

--Assign
---c [int Lvalue Write Value]
---Op: +  [int Rvalue]
----Literal: 3 [int Rvalue]
----Literal: 4 [int Rvalue]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 1 b of type int]
2: Symbol: [ in scope 1 c of type int]
3: Symbol: [ in scope 0 main of type function: ()->void]

IR dump:
0: %0 = LoadI(1)
1: JumpCondTrue %0 to:3
2: JumpCondFalse %0 to:8
3: %1 = LoadI(2)
4: %2 = LoadI(3)
5: %3 = %1 + %2
6: store %3 to [MainDS:b 1]
7: JumpCondFalse %0 to:0
8: %5 = LoadI(3)
9: %6 = LoadI(4)
10: %7 = %5 + %6
11: store %7 to [MainDS:c 2]

---------------------------------------------------
Parsing: "void main(){ int a, b; if(true){int c; a=2+3;} else{ int d, e,f; d = 4; } int g; b=5+6; }"

Scopes of module:
Scope 0: {(7:main) }
Scope 1: {(0:a) (1:b) (6:g) }
Scope 2: {(2:c) }
Scope 3: {(3:d) (4:e) (5:f) }


AST dump:
-int a int b 
-IfStmt:
--Cond: Literal: 1 [bool Rvalue]
--Then:
---int c 
---Assign
----a [int Lvalue Write Value]
----Op: +  [int Rvalue]
-----Literal: 2 [int Rvalue]
-----Literal: 3 [int Rvalue]
--Else:
---int d int e int f 
---Assign
----d [int Lvalue Write Value]
----Literal: 4 [int Rvalue]

-int g 
-Assign
--b [int Lvalue Write Value]
--Op: +  [int Rvalue]
---Literal: 5 [int Rvalue]
---Literal: 6 [int Rvalue]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 1 b of type int]
2: Symbol: [ in scope 2 c of type int]
3: Symbol: [ in scope 3 d of type int]
4: Symbol: [ in scope 3 e of type int]
5: Symbol: [ in scope 3 f of type int]
6: Symbol: [ in scope 1 g of type int]
7: Symbol: [ in scope 0 main of type function: ()->void]

IR dump:
0: %0 = LoadI(1)
1: JumpCondTrue %0 to:3
2: JumpCondFalse %0 to:8
3: %1 = LoadI(2)
4: %2 = LoadI(3)
5: %3 = %1 + %2
6: store %3 to [MainDS:a 0]
7: JumpIncond11
8: %5 = LoadI(4)
9: store %5 to [MainDS:d 2]
10: JumpIncond11
11: %7 = LoadI(5)
12: %8 = LoadI(6)
13: %9 = %7 + %8
14: store %9 to [MainDS:b 1]

---------------------------------------------------
Parsing: "void main(){int a,b; int* p; a=*p; b=2; p = &b; a = b + *p;}"

Scopes of module:
Scope 0: {(3:main) }
Scope 1: {(0:a) (1:b) (2:p) }


AST dump:
-int a int b 
-int* p 
-Assign
--a [int Lvalue Write Value]
--* [int Lvalue Read]
---p [int* Lvalue Read Value]
-Assign
--b [int Lvalue Write Value]
--Literal: 2 [int Rvalue]
-Assign
--p [int* Lvalue Write Value]
--@ [int* Lvalue]
---b [int Lvalue Read Address]
-Assign
--a [int Lvalue Write Value]
--Op: +  [int Rvalue]
---b [int Lvalue Read Value]
---* [int Lvalue Read]
----p [int* Lvalue Read Value]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 1 b of type int]
2: Symbol: [ in scope 1 p of type int*]
3: Symbol: [ in scope 0 main of type function: ()->void]

IR dump:
0: %0 = Load [MainDS:p 2]
1: %1 = Load [ %0]
2: store %1 to [MainDS:a 0]
3: %3 = LoadI(2)
4: store %3 to [MainDS:b 1]
5: %5 = PtrElem( MainDS:b 1)
6: store %5 to [MainDS:p 2]
7: %7 = Load [MainDS:b 1]
8: %8 = Load [MainDS:p 2]
9: %9 = Load [ %8]
10: %10 = %7 + %9
11: store %10 to [MainDS:a 0]

---------------------------------------------------
Parsing: "void main(){int a; a= 2;} void f(int p1){int a; a=p1;}"

Scopes of module:
Scope 0: {(1:main) (4:f) }
Scope 1: {(0:a) }
Scope 2: {(2:p1) (3:a) }


AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--Literal: 2 [int Rvalue]
-int a 
-Assign
--a [int Lvalue Write Value]
--p1 [int Lvalue Read Value]

Declaration Table:
0: Symbol: [ in scope 1 a of type int]
1: Symbol: [ in scope 0 main of type function: ()->void]
2: Symbol: [ in scope 2 p1 of type int]
3: Symbol: [ in scope 2 a of type int]
4: Symbol: [ in scope 0 f of type function: (int)->void]

IR dump:
0: %0 = LoadI(2)
1: store %0 to [MainDS:a 0]
2: %2 = Load [arp_f:p1 -2]
3: store %2 to [arp_f:a 0]

---------------------------------------------------
Parsing: "int f(int p1){int a; a=p1;} void main(){int a; a=f(2);}"

Scopes of module:
Scope 0: {(2:f) (4:main) }
Scope 1: {(0:p1) (1:a) }
Scope 2: {(3:a) }


AST dump:
-int a 
-Assign
--a [int Lvalue Write Value]
--p1 [int Lvalue Read Value]
-int a 
-Assign
--a [int Lvalue Write Value]
--Literal: 2 [int]

Declaration Table:
0: Symbol: [ in scope 1 p1 of type int]
1: Symbol: [ in scope 1 a of type int]
2: Symbol: [ in scope 0 f of type function: (int)->int]
3: Symbol: [ in scope 2 a of type int]
4: Symbol: [ in scope 0 main of type function: ()->void]

IR dump:
0: store %0 to [MainDS:a 0]
1: %1 = Load [arp_f:p1 -2]
2: store %1 to [arp_f:a 0]


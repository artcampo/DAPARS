Grammar:
PROG -> E  init 
E -> T E' 
E' -> + T E' 
E' -> - T E' 
E' -> {empty} 
T -> F T' 
T' -> * F T' 
T' -> / F T' 
T' -> {empty} 
F -> ( E ) 
F -> {num} 
F -> {nam} 

---------------------------------------------------
Parsing: "if(1+2){int a;} int b;"

AST dump:
-IfStmt:
--Cond: Op: + 
---Literal: 1
---Literal: 2
--Then:
------int a 

--int b 
P
BBlock {If VarDecl: int b  } with successor: ProgEnd
**Backpatch try [Block {If VarDecl: int b  }]:(0x56233cabcad0)
**Backpatch try [If]:(0x56233cabc970)
IfIf with successor: VarDecl: int b 
**Backpatch insert [Block {VarDecl: int a  }] has to patch:jump if trueto:0
**Backpatch insert [VarDecl: int b ] has to patch:jump if falseto:0
BBlock {VarDecl: int a  } with successor: VarDecl: int b 
**Backpatch try [Block {VarDecl: int a  }]:(0x56233cabc8c0)Backpatch: jump if trueto:0 with node: Block {VarDecl: int a  }

**Backpatch try [VarDecl: int a ]:(0x56233cabc890)
DVarDecl: int a  with successor: VarDecl: int b 
**Backpatch insert [VarDecl: int b ] has to patch:JUMP: @0

**Backpatch try [VarDecl: int b ]:(0x56233cabcaa0)Backpatch: jump if falseto:0 with node: VarDecl: int b 
Backpatch: JUMP: @0 with node: VarDecl: int b 

DVarDecl: int b  with successor: ProgEnd
0: Load, r:0 val: 1
1: Load, r:1 val: 2
2: ADD, rs1:0 rs2: 1 rd:2
3: jump if trueto:5
4: jump if falseto:7
5: NewVar: TypeId0
6: JUMP: @7
7: NewVar: TypeId0
8: STOP

